use super::super::structures::matrix::Matrix;
use std::f32::consts::PI;

pub fn compute(samples: &[f32]) -> Matrix<f32>
{
    let mut z = [0.0; C_LEN];
    let mut y = [0.0; M_COLS];
    let mut mr: Matrix<f32> = Matrix::new(M_ROWS, M_COLS);
    let mut mi: Matrix<f32> = Matrix::new(M_ROWS, M_COLS);

    for i in 0..M_ROWS {
        for j in 0..M_COLS {
            let i_signed = i as i32;
            let j_signed = j as i32;
            let temp = ((2 * i_signed + 1) * (j_signed - 4)) as f32 * (PI / 16.0);
            mr[[i, j]] = temp.cos();
            mi[[i, j]] = temp.sin();
        }
    }

    let num_frames = (samples.len() - C_LEN + 1) / SUBBANDS;
    if num_frames <= 0 {
        panic!(format!("Invalid frames number: {}", num_frames));
    }

    let mut data: Matrix<f32> = Matrix::new(SUBBANDS, num_frames);

    for t in 0..num_frames {
        for i in 0..C_LEN {
            z[i] = samples[t * SUBBANDS + i] * C[i];
        }

        for i in 0..M_COLS {
            y[i] = z[i];
        }

        for i in 0..M_COLS {
            for j in 1..M_ROWS {
                y[i] = y[i] + z[i + M_COLS * j];
            }
        }

        for i in 0..M_ROWS {
            let mut dr = 0.0;
            let mut di = 0.0;

            for j in 0..M_COLS {
                dr = dr + mr[[i, j]] * y[j];
                di = di - mi[[i, j]] * y[j];
            }
            data[[i, t]] = dr.powi(2) + di.powi(2);
        }
    }

    data
}

const C_LEN: usize = 128;
const SUBBANDS: usize = 8;
const M_ROWS: usize = 8;
const M_COLS: usize = 16;

const C: [f32;C_LEN] = [
    0.000000477,  0.000000954,  0.000001431,  0.000002384,  0.000003815,  0.000006199,  0.000009060,  0.000013828,
    0.000019550,  0.000027657,  0.000037670,  0.000049591,  0.000062943,  0.000076771,  0.000090599,  0.000101566,
    -0.000108242, -0.000106812, -0.000095367, -0.000069618, -0.000027180,  0.000034332,  0.000116348,  0.000218868,
    0.000339031,  0.000472546,  0.000611782,  0.000747204,  0.000866413,  0.000954151,  0.000994205,  0.000971317,
    -0.000868797, -0.000674248, -0.000378609,  0.000021458,  0.000522137,  0.001111031,  0.001766682,  0.002457142,
    0.003141880,  0.003771782,  0.004290581,  0.004638195,  0.004752159,  0.004573822,  0.004049301,  0.003134727,
    -0.001800537, -0.000033379,  0.002161503,  0.004756451,  0.007703304,  0.010933399,  0.014358521,  0.017876148,
    0.021372318,  0.024725437,  0.027815342,  0.030526638,  0.032754898,  0.034412861,  0.035435200,  0.035780907,
    -0.035435200, -0.034412861, -0.032754898, -0.030526638, -0.027815342, -0.024725437, -0.021372318, -0.017876148,
    -0.014358521, -0.010933399, -0.007703304, -0.004756451, -0.002161503,  0.000033379,  0.001800537,  0.003134727,
    -0.004049301, -0.004573822, -0.004752159, -0.004638195, -0.004290581, -0.003771782, -0.003141880, -0.002457142,
    -0.001766682, -0.001111031, -0.000522137, -0.000021458,  0.000378609,  0.000674248,  0.000868797,  0.000971317,
    -0.000994205, -0.000954151, -0.000866413, -0.000747204, -0.000611782, -0.000472546, -0.000339031, -0.000218868,
    -0.000116348, -0.000034332,  0.000027180,  0.000069618,  0.000095367,  0.000106812,  0.000108242,  0.000101566,
    -0.000090599, -0.000076771, -0.000062943, -0.000049591, -0.000037670, -0.000027657, -0.000019550, -0.000013828,
    -0.000009060, -0.000006199, -0.000003815, -0.000002384, -0.000001431, -0.000000954, -0.000000477, 0.0
];